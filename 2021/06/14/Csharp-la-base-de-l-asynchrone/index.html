<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>C# : la base de l&#39;asynchrone | Daily knowledge extract</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="AJA un peu plus précisément comment fonctionnait le système de gestion des tâches asynchrones en C#. J’ai découvert une page de documentation microsoft vraiment bien écrite pour découvrir (ou redécouv">
<meta property="og:type" content="article">
<meta property="og:title" content="C# : la base de l&#39;asynchrone">
<meta property="og:url" content="http://blueint32.github.io/2021/06/14/Csharp-la-base-de-l-asynchrone/index.html">
<meta property="og:site_name" content="Daily knowledge extract">
<meta property="og:description" content="AJA un peu plus précisément comment fonctionnait le système de gestion des tâches asynchrones en C#. J’ai découvert une page de documentation microsoft vraiment bien écrite pour découvrir (ou redécouv">
<meta property="og:locale" content="fr_FR">
<meta property="article:published_time" content="2021-06-14T05:01:14.000Z">
<meta property="article:modified_time" content="2021-06-15T05:24:30.494Z">
<meta property="article:author" content="BlueInt32">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Daily knowledge extract" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Daily knowledge extract</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">À propos</a>
        
          <a class="main-nav-link" href="/contact">Contact</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Rechercher"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blueint32.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Csharp-la-base-de-l-asynchrone" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/14/Csharp-la-base-de-l-asynchrone/" class="article-date">
  <time class="dt-published" datetime="2021-06-14T05:01:14.000Z" itemprop="datePublished">2021-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      C# : la base de l&#39;asynchrone
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>AJA un peu plus précisément comment fonctionnait le système de gestion des tâches asynchrones en C#. J’ai découvert <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/">une page de documentation microsoft</a> vraiment bien écrite pour découvrir (ou redécouvrir) le sujet en détail. </p>
<p>L’article est fondé sur l’analogie de la préparation d’un petit déjeuner : certaines des tâches ne nécessitent pas la présence constante d’un cuistot, par exemple pendant que les tartines cuisent dans le grille-pain. On comprend intuitivement que personne de sain d’esprit ne resterait planté devant le grille-pain alors qu’il est possible de cuire les oeufs et de verser le jus d’orange en attendant. On parle de tâche asynchrone.</p>
<p>En .net, ce concept de tâche asynchrone est implémenté à l’aide de l’objet <code>Task</code>. Il représente non pas l’action de faire quelque chose (comme le ferait une fonction quelconque) mais plutôt le fait qu’une action est en cours, il s’agit donc d’une représentation de son status. Cela correspond pratiquement à la notion de promesse en JS.</p>
<p>Concrètement, il peut s’agir d’un appel à un service externe. Voici un exemple particulièrement utile : </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;ImportantData&gt; <span class="title">GetDataAsync</span>(<span class="params"><span class="built_in">int</span> taskNumber</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;\tLong task start &quot;</span> + taskNumber);</span><br><span class="line">		Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;\tTick &quot;</span> + taskNumber);</span><br><span class="line">		Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;\tTick &quot;</span> + taskNumber);</span><br><span class="line">		Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;\tLong task finish &quot;</span> + taskNumber);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ImportantData();</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Un utilisateur de cette méthode asynchrone pourra adopter plusieurs stratégies, plus ou moins efficaces. </p>
<p>Tout d’abord il est possible d’appeler cette méthode sans syntaxe particulière comme ceci : </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program start&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> gettingImportantData1 = SlowService.GetDataAsync(<span class="number">1</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Synchronous task&quot;</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ici, l’éxecution ne va pas se bloquer pour attendre <code>GetDataAsync</code>. Cela veut dire que le programme va se terminer avant même que la tâche ait effectué son premier “tick” : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Program start</span><br><span class="line">        Long task start 1</span><br><span class="line">Synchronous task</span><br><span class="line">Program end</span><br></pre></td></tr></table></figure>

<p>Autre possibilité : attendre.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program start&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> gettingImportantData1 = <span class="keyword">await</span> SlowService.GetDataAsync(<span class="number">1</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Synchronous task&quot;</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dans ce cas, le programme va suspendre son execution et attendre la fin de la tâche longue avant de reprendre : on note cependant que la tâche synchrône est toujours effectuée après la tâche longue.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Program start</span><br><span class="line">        Long task start 1</span><br><span class="line">        Tick 1</span><br><span class="line">        Tick 1</span><br><span class="line">        Long task finish 1</span><br><span class="line">Synchronous task</span><br><span class="line">Program end</span><br></pre></td></tr></table></figure>

<p>⚠️ Ici, il est important de noter que pendant l’exécution de la tâche longue (avec <code>await</code>), la CLR relâche le thread. Dans un contexte web ou client WPF par exemple, cela signifie que d’autres actions utilisateurs pourront être prises en charge par ce thread en attendant. Ce n’est pas du tout négligeable pour la scalabilité.</p>
<p>Toujours est-il que notre programme en tant que tel n’est pas très optimisé : en effet, je préfèrerais largement gagner du temps sur l’éxecution de ma tâche synchrone et l’effectuer en parallèle de la tâche longue. Et qui sait, peut-être voudrais-je appeler deux fois ma tâche longue avec d’autres paramètres !</p>
<p>C’est très simple, il suffit d’ordonnancer les appels de façon intuitive par rapport aux tâches : </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program start&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> gettingImportantData1 = SlowService.GetDataAsync(<span class="number">1</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Synchronous task&quot;</span>);</span><br><span class="line">	<span class="keyword">await</span> gettingImportantData1;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>On voit ici qu’il y a une différence entre démarrer une tâche asynchrône, et forcer l’attente de la fin de son exécution. L’objet <code>Task</code> permet de garder la main sur cela et d’avoir enfin un programme performant :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Program start</span><br><span class="line">        Long task start 1</span><br><span class="line">Synchronous task</span><br><span class="line">        Tick 1</span><br><span class="line">        Tick 1</span><br><span class="line">        Long task finish 1</span><br><span class="line">Program end</span><br></pre></td></tr></table></figure>

<p>Et comme je l’avais envisagé, je peux appeler ma tâche longue plusieurs fois en parallèle : </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program start&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> gettingImportantData1 = SlowService.GetDataAsync(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">var</span> gettingImportantData2 = SlowService.GetDataAsync(<span class="number">2</span>);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Synchronous task&quot;</span>);</span><br><span class="line">	<span class="keyword">await</span> gettingImportantData1;</span><br><span class="line">	<span class="keyword">await</span> gettingImportantData2;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Program end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Et ainsi obtenir le parallelisme attendu :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Program start</span><br><span class="line">Synchronous task</span><br><span class="line">        Long task start 1</span><br><span class="line">        Long task start 2</span><br><span class="line">        Tick 1</span><br><span class="line">        Tick 2</span><br><span class="line">        Tick 1</span><br><span class="line">        Tick 2</span><br><span class="line">        Long task finish 1</span><br><span class="line">        Long task finish 2</span><br><span class="line">Program end</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueint32.github.io/2021/06/14/Csharp-la-base-de-l-asynchrone/" data-id="ckpxlpaxi00048fnf3haq7b9j" data-title="C# : la base de l&#39;asynchrone" class="article-share-link">Partager</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/06/01/html-js-astuce-pour-telecharger-un-fichier-depuis-le-browser/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">HTML/JS : astuce pour générer un fichier téléchargeable depuis le browser</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bash/" rel="tag">bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuejs/" rel="tag">vuejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web-components/" rel="tag">web components</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">juin 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">mai 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/14/Csharp-la-base-de-l-asynchrone/">C# : la base de l&#39;asynchrone</a>
          </li>
        
          <li>
            <a href="/2021/06/01/html-js-astuce-pour-telecharger-un-fichier-depuis-le-browser/">HTML/JS : astuce pour générer un fichier téléchargeable depuis le browser</a>
          </li>
        
          <li>
            <a href="/2021/05/15/JS-une-syntaxe-marrante-pour-filtrer/">JS : une syntaxe marrante pour filtrer</a>
          </li>
        
          <li>
            <a href="/2021/05/15/CSS-comprendre-les-ellipses-de-texte/">CSS : comprendre les ellipses de texte</a>
          </li>
        
          <li>
            <a href="/2021/05/15/Vim-plus-de-flexibilite-avec-vim-surround/">Vim : plus de flexibilité avec vim-surround</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 BlueInt32<br>
      Propulsé par <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">À propos</a>
  
    <a href="/contact" class="mobile-nav-link">Contact</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>